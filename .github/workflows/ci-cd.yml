name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    
    services:
      # Use MySQL service container for integration tests if needed
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: password
          MYSQL_DATABASE: test_db
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python 3.9
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r t1_cs/requirements.txt
          pip install pytest pytest-cov
      
      - name: Run unit tests
        run: |
          pytest t1_cs/tests/test_models.py t1_cs/tests/test_repositories.py t1_cs/tests/test_services.py --cov=t1_cs/app --cov-report=xml
      
      - name: Run database tests
        run: |
          pytest t1_cs/tests/test_database.py --cov=t1_cs/app --cov-append --cov-report=xml
      
      - name: Verify coverage report
        run: |
          if [ -f "coverage.xml" ]; then
            echo "Coverage report found at $(pwd)/coverage.xml"
          else
            echo "Warning: coverage.xml not found in expected location"
            find . -name "coverage.xml" -type f
          fi
      
      - name: Upload test coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: ./coverage.xml
          if-no-files-found: warn
      
      - name: Build Docker image
        run: |
          docker build -t fastapi-app:${{ github.sha }} .
      
      - name: Test Docker image
        run: |
          docker run --name test-container -d -p 8000:8000 fastapi-app:${{ github.sha }}
          sleep 5
          if ! curl -s http://localhost:8000/health; then
            echo "Health check failed"
            docker logs test-container
            docker stop test-container
            docker rm test-container
            exit 1
          fi
          docker stop test-container
          docker rm test-container

  deploy:
    name: Deploy to AWS
    needs: build-and-test
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Check if AWS credentials are valid
      - name: Check AWS credentials
        id: aws-cred-check
        continue-on-error: true
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          AWS_REGION: us-east-1
        run: |
          echo "::warning::Checking AWS credentials..."
          if aws sts get-caller-identity &>/dev/null; then
            echo "AWS credentials are valid"
            echo "aws_creds_valid=true" >> $GITHUB_OUTPUT
          else
            echo "::error::AWS credentials are invalid or expired. For temporary credentials (Access Key ID starting with 'ASIA'), you need to provide AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, and AWS_SESSION_TOKEN."
            echo "aws_creds_valid=false" >> $GITHUB_OUTPUT
          fi
      
      # Set AWS credentials as environment variables if they're valid
      - name: Set AWS credentials as environment variables
        if: steps.aws-cred-check.outputs.aws_creds_valid == 'true'
        run: |
          echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=${{ secrets.AWS_SESSION_TOKEN }}" >> $GITHUB_ENV
          echo "AWS_REGION=us-east-1" >> $GITHUB_ENV
          echo "AWS credentials set as environment variables"
      
      # Setup Terraform only if AWS credentials are valid
      - name: Setup Terraform
        if: steps.aws-cred-check.outputs.aws_creds_valid == 'true'
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.7.0
      
      # Initialize Terraform only if AWS credentials are valid
      - name: Terraform Init
        if: steps.aws-cred-check.outputs.aws_creds_valid == 'true'
        working-directory: ./terraform
        run: |
          # Use local backend instead of S3 since the bucket doesn't exist
          terraform init -backend=false
      
      # Create S3 bucket for Terraform state if it doesn't exist
      - name: Create S3 bucket for Terraform state
        if: steps.aws-cred-check.outputs.aws_creds_valid == 'true'
        run: |
          # Create a valid S3 bucket name (must be lowercase, no underscores, etc.)
          # Use a hash of the repository name to ensure uniqueness and valid characters
          REPO_HASH=$(echo "${{ github.repository }}" | md5sum | cut -c1-8)
          BUCKET_NAME="tf-state-$REPO_HASH"
          echo "Using S3 bucket: $BUCKET_NAME"
          
          # Check if bucket exists
          if aws s3api head-bucket --bucket $BUCKET_NAME 2>/dev/null; then
            echo "S3 bucket already exists"
          else
            echo "Creating S3 bucket: $BUCKET_NAME"
            # Create bucket in us-east-1
            aws s3api create-bucket --bucket $BUCKET_NAME --region us-east-1
            
            # Enable versioning
            aws s3api put-bucket-versioning --bucket $BUCKET_NAME --versioning-configuration Status=Enabled
            
            # Wait for bucket to be fully created
            echo "Waiting for bucket to be available..."
            sleep 10
          fi
          
          # Store bucket name for later use
          echo "TF_BUCKET_NAME=$BUCKET_NAME" >> $GITHUB_ENV
      
      # Initialize Terraform with S3 backend
      - name: Terraform Init
        if: steps.aws-cred-check.outputs.aws_creds_valid == 'true'
        working-directory: ./terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ env.TF_BUCKET_NAME }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=us-east-1"
      
      # Validate Terraform only if AWS credentials are valid
      - name: Terraform Validate
        if: steps.aws-cred-check.outputs.aws_creds_valid == 'true'
        working-directory: ./terraform
        run: terraform validate
      
      # Plan Terraform only if AWS credentials are valid
      - name: Terraform Plan
        if: steps.aws-cred-check.outputs.aws_creds_valid == 'true'
        working-directory: ./terraform
        run: terraform plan -var-file=terraform.tfvars
        env:
          TF_VAR_db_username: ${{ secrets.DB_USERNAME }}
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
          TF_VAR_environment: "prod"
      
      # Apply Terraform only if AWS credentials are valid
      - name: Terraform Apply
        if: steps.aws-cred-check.outputs.aws_creds_valid == 'true' && github.ref == 'refs/heads/main' && github.event_name == 'push'
        working-directory: ./terraform
        run: terraform apply -auto-approve -var-file=terraform.tfvars
        env:
          TF_VAR_db_username: ${{ secrets.DB_USERNAME }}
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
          TF_VAR_environment: "prod"
      
      # Get API Gateway URL only if AWS credentials are valid
      - name: Get API Gateway URL
        if: steps.aws-cred-check.outputs.aws_creds_valid == 'true'
        working-directory: ./terraform
        run: |
          # Extract the API Gateway URL and ensure it's properly formatted
          API_URL=$(terraform output -raw api_gateway_url | tr -d '\n' | tr -d '\r')
          echo "API_URL=${API_URL}" >> $GITHUB_ENV
          echo "API Gateway URL: ${API_URL}"
      
      # Wait for deployment only if AWS credentials are valid
      - name: Wait for deployment to complete
        if: steps.aws-cred-check.outputs.aws_creds_valid == 'true'
        run: |
          echo "Waiting for Lambda function to be fully deployed..."
          sleep 30
      
      # Test deployed API only if AWS credentials are valid
      - name: Test deployed API
        if: steps.aws-cred-check.outputs.aws_creds_valid == 'true'
        run: |
          echo "Testing API at ${{ env.API_URL }}"
          curl -s ${{ env.API_URL }}/health
      
      # Display warning if AWS credentials are invalid
      - name: AWS credentials warning
        if: steps.aws-cred-check.outputs.aws_creds_valid != 'true'
        run: |
          echo "::warning::Skipping deployment steps due to invalid AWS credentials. Please update the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY secrets."
      
      - name: Send deployment notification
        if: always()
        uses: rtCamp/action-slack-notify@v2.2.0
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_CHANNEL: deployments
          SLACK_COLOR: ${{ job.status }}
          SLACK_TITLE: Deployment ${{ job.status }}
          SLACK_MESSAGE: "API deployed to ${{ env.API_URL }}"